Directory structure:
â””â”€â”€ anthropics-claude-agent-sdk-python/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ CHANGELOG.md
    â”œâ”€â”€ CLAUDE.md
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ pyproject.toml
    â”œâ”€â”€ e2e-tests/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ conftest.py
    â”‚   â”œâ”€â”€ test_agents_and_settings.py
    â”‚   â”œâ”€â”€ test_dynamic_control.py
    â”‚   â”œâ”€â”€ test_hooks.py
    â”‚   â”œâ”€â”€ test_include_partial_messages.py
    â”‚   â”œâ”€â”€ test_sdk_mcp_tools.py
    â”‚   â”œâ”€â”€ test_stderr_callback.py
    â”‚   â””â”€â”€ test_tool_permissions.py
    â”œâ”€â”€ examples/
    â”‚   â”œâ”€â”€ agents.py
    â”‚   â”œâ”€â”€ hooks.py
    â”‚   â”œâ”€â”€ include_partial_messages.py
    â”‚   â”œâ”€â”€ max_budget_usd.py
    â”‚   â”œâ”€â”€ mcp_calculator.py
    â”‚   â”œâ”€â”€ plugin_example.py
    â”‚   â”œâ”€â”€ quick_start.py
    â”‚   â”œâ”€â”€ setting_sources.py
    â”‚   â”œâ”€â”€ stderr_callback_example.py
    â”‚   â”œâ”€â”€ streaming_mode.py
    â”‚   â”œâ”€â”€ streaming_mode_ipython.py
    â”‚   â”œâ”€â”€ streaming_mode_trio.py
    â”‚   â”œâ”€â”€ system_prompt.py
    â”‚   â”œâ”€â”€ tool_permission_callback.py
    â”‚   â””â”€â”€ plugins/
    â”‚       â””â”€â”€ demo-plugin/
    â”‚           â”œâ”€â”€ commands/
    â”‚           â”‚   â””â”€â”€ greet.md
    â”‚           â””â”€â”€ .claude-plugin/
    â”‚               â””â”€â”€ plugin.json
    â”œâ”€â”€ scripts/
    â”‚   â”œâ”€â”€ initial-setup.sh
    â”‚   â”œâ”€â”€ pre-push
    â”‚   â””â”€â”€ update_version.py
    â”œâ”€â”€ src/
    â”‚   â””â”€â”€ claude_agent_sdk/
    â”‚       â”œâ”€â”€ __init__.py
    â”‚       â”œâ”€â”€ _errors.py
    â”‚       â”œâ”€â”€ _version.py
    â”‚       â”œâ”€â”€ client.py
    â”‚       â”œâ”€â”€ py.typed
    â”‚       â”œâ”€â”€ query.py
    â”‚       â”œâ”€â”€ types.py
    â”‚       â””â”€â”€ _internal/
    â”‚           â”œâ”€â”€ __init__.py
    â”‚           â”œâ”€â”€ client.py
    â”‚           â”œâ”€â”€ message_parser.py
    â”‚           â”œâ”€â”€ query.py
    â”‚           â””â”€â”€ transport/
    â”‚               â”œâ”€â”€ __init__.py
    â”‚               â””â”€â”€ subprocess_cli.py
    â”œâ”€â”€ tests/
    â”‚   â”œâ”€â”€ conftest.py
    â”‚   â”œâ”€â”€ test_changelog.py
    â”‚   â”œâ”€â”€ test_client.py
    â”‚   â”œâ”€â”€ test_errors.py
    â”‚   â”œâ”€â”€ test_integration.py
    â”‚   â”œâ”€â”€ test_message_parser.py
    â”‚   â”œâ”€â”€ test_sdk_mcp_integration.py
    â”‚   â”œâ”€â”€ test_streaming_client.py
    â”‚   â”œâ”€â”€ test_subprocess_buffering.py
    â”‚   â”œâ”€â”€ test_tool_callbacks.py
    â”‚   â”œâ”€â”€ test_transport.py
    â”‚   â””â”€â”€ test_types.py
    â”œâ”€â”€ .claude/
    â”‚   â”œâ”€â”€ settings.json
    â”‚   â””â”€â”€ commands/
    â”‚       â”œâ”€â”€ commit.md
    â”‚       â””â”€â”€ generate-changelog.md
    â””â”€â”€ .github/
        â””â”€â”€ workflows/
            â”œâ”€â”€ claude-code-review.yml
            â”œâ”€â”€ claude-issue-triage.yml
            â”œâ”€â”€ claude.yml
            â”œâ”€â”€ create-release-tag.yml
            â”œâ”€â”€ lint.yml
            â”œâ”€â”€ publish.yml
            â””â”€â”€ test.yml

================================================
FILE: README.md
================================================
# Claude Agent SDK for Python

Python SDK for Claude Agent. See the [Claude Agent SDK documentation](https://docs.anthropic.com/en/docs/claude-code/sdk/sdk-python) for more information.

## Installation

```bash
pip install claude-agent-sdk
```

**Prerequisites:**
- Python 3.10+
- Node.js
- Claude Code 2.0.0+: `npm install -g @anthropic-ai/claude-code`

## Quick Start

```python
import anyio
from claude_agent_sdk import query

async def main():
    async for message in query(prompt="What is 2 + 2?"):
        print(message)

anyio.run(main)
```

## Basic Usage: query()

`query()` is an async function for querying Claude Code. It returns an `AsyncIterator` of response messages. See [src/claude_agent_sdk/query.py](src/claude_agent_sdk/query.py).

```python
from claude_agent_sdk import query, ClaudeAgentOptions, AssistantMessage, TextBlock

# Simple query
async for message in query(prompt="Hello Claude"):
    if isinstance(message, AssistantMessage):
        for block in message.content:
            if isinstance(block, TextBlock):
                print(block.text)

# With options
options = ClaudeAgentOptions(
    system_prompt="You are a helpful assistant",
    max_turns=1
)

async for message in query(prompt="Tell me a joke", options=options):
    print(message)
```

### Using Tools

```python
options = ClaudeAgentOptions(
    allowed_tools=["Read", "Write", "Bash"],
    permission_mode='acceptEdits'  # auto-accept file edits
)

async for message in query(
    prompt="Create a hello.py file",
    options=options
):
    # Process tool use and results
    pass
```

### Working Directory

```python
from pathlib import Path

options = ClaudeAgentOptions(
    cwd="/path/to/project"  # or Path("/path/to/project")
)
```

## ClaudeSDKClient

`ClaudeSDKClient` supports bidirectional, interactive conversations with Claude
Code. See [src/claude_agent_sdk/client.py](src/claude_agent_sdk/client.py).

Unlike `query()`, `ClaudeSDKClient` additionally enables **custom tools** and **hooks**, both of which can be defined as Python functions.

### Custom Tools (as In-Process SDK MCP Servers)

A **custom tool** is a Python function that you can offer to Claude, for Claude to invoke as needed.

Custom tools are implemented in-process MCP servers that run directly within your Python application, eliminating the need for separate processes that regular MCP servers require.

For an end-to-end example, see [MCP Calculator](examples/mcp_calculator.py).

#### Creating a Simple Tool

```python
from claude_agent_sdk import tool, create_sdk_mcp_server, ClaudeAgentOptions, ClaudeSDKClient

# Define a tool using the @tool decorator
@tool("greet", "Greet a user", {"name": str})
async def greet_user(args):
    return {
        "content": [
            {"type": "text", "text": f"Hello, {args['name']}!"}
        ]
    }

# Create an SDK MCP server
server = create_sdk_mcp_server(
    name="my-tools",
    version="1.0.0",
    tools=[greet_user]
)

# Use it with Claude
options = ClaudeAgentOptions(
    mcp_servers={"tools": server},
    allowed_tools=["mcp__tools__greet"]
)

async with ClaudeSDKClient(options=options) as client:
    await client.query("Greet Alice")

    # Extract and print response
    async for msg in client.receive_response():
        print(msg)
```

#### Benefits Over External MCP Servers

- **No subprocess management** - Runs in the same process as your application
- **Better performance** - No IPC overhead for tool calls
- **Simpler deployment** - Single Python process instead of multiple
- **Easier debugging** - All code runs in the same process
- **Type safety** - Direct Python function calls with type hints

#### Migration from External Servers

```python
# BEFORE: External MCP server (separate process)
options = ClaudeAgentOptions(
    mcp_servers={
        "calculator": {
            "type": "stdio",
            "command": "python",
            "args": ["-m", "calculator_server"]
        }
    }
)

# AFTER: SDK MCP server (in-process)
from my_tools import add, subtract  # Your tool functions

calculator = create_sdk_mcp_server(
    name="calculator",
    tools=[add, subtract]
)

options = ClaudeAgentOptions(
    mcp_servers={"calculator": calculator}
)
```

#### Mixed Server Support

You can use both SDK and external MCP servers together:

```python
options = ClaudeAgentOptions(
    mcp_servers={
        "internal": sdk_server,      # In-process SDK server
        "external": {                # External subprocess server
            "type": "stdio",
            "command": "external-server"
        }
    }
)
```

### Hooks

A **hook** is a Python function that the Claude Code *application* (*not* Claude) invokes at specific points of the Claude agent loop. Hooks can provide deterministic processing and automated feedback for Claude. Read more in [Claude Code Hooks Reference](https://docs.anthropic.com/en/docs/claude-code/hooks).

For more examples, see examples/hooks.py.

#### Example

```python
from claude_agent_sdk import ClaudeAgentOptions, ClaudeSDKClient, HookMatcher

async def check_bash_command(input_data, tool_use_id, context):
    tool_name = input_data["tool_name"]
    tool_input = input_data["tool_input"]
    if tool_name != "Bash":
        return {}
    command = tool_input.get("command", "")
    block_patterns = ["foo.sh"]
    for pattern in block_patterns:
        if pattern in command:
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": f"Command contains invalid pattern: {pattern}",
                }
            }
    return {}

options = ClaudeAgentOptions(
    allowed_tools=["Bash"],
    hooks={
        "PreToolUse": [
            HookMatcher(matcher="Bash", hooks=[check_bash_command]),
        ],
    }
)

async with ClaudeSDKClient(options=options) as client:
    # Test 1: Command with forbidden pattern (will be blocked)
    await client.query("Run the bash command: ./foo.sh --help")
    async for msg in client.receive_response():
        print(msg)

    print("\n" + "=" * 50 + "\n")

    # Test 2: Safe command that should work
    await client.query("Run the bash command: echo 'Hello from hooks example!'")
    async for msg in client.receive_response():
        print(msg)
```


## Types

See [src/claude_agent_sdk/types.py](src/claude_agent_sdk/types.py) for complete type definitions:
- `ClaudeAgentOptions` - Configuration options
- `AssistantMessage`, `UserMessage`, `SystemMessage`, `ResultMessage` - Message types
- `TextBlock`, `ToolUseBlock`, `ToolResultBlock` - Content blocks

## Error Handling

```python
from claude_agent_sdk import (
    ClaudeSDKError,      # Base error
    CLINotFoundError,    # Claude Code not installed
    CLIConnectionError,  # Connection issues
    ProcessError,        # Process failed
    CLIJSONDecodeError,  # JSON parsing issues
)

try:
    async for message in query(prompt="Hello"):
        pass
except CLINotFoundError:
    print("Please install Claude Code")
except ProcessError as e:
    print(f"Process failed with exit code: {e.exit_code}")
except CLIJSONDecodeError as e:
    print(f"Failed to parse response: {e}")
```

See [src/claude_agent_sdk/_errors.py](src/claude_agent_sdk/_errors.py) for all error types.

## Available Tools

See the [Claude Code documentation](https://docs.anthropic.com/en/docs/claude-code/settings#tools-available-to-claude) for a complete list of available tools.

## Examples

See [examples/quick_start.py](examples/quick_start.py) for a complete working example.

See [examples/streaming_mode.py](examples/streaming_mode.py) for comprehensive examples involving `ClaudeSDKClient`. You can even run interactive examples in IPython from [examples/streaming_mode_ipython.py](examples/streaming_mode_ipython.py).

## Migrating from Claude Code SDK

If you're upgrading from the Claude Code SDK (versions < 0.1.0), please see the [CHANGELOG.md](CHANGELOG.md#010) for details on breaking changes and new features, including:

- `ClaudeCodeOptions` â†’ `ClaudeAgentOptions` rename
- Merged system prompt configuration
- Settings isolation and explicit control
- New programmatic subagents and session forking features

## Development

If you're contributing to this project, run the initial setup script to install git hooks:

```bash
./scripts/initial-setup.sh
```

This installs a pre-push hook that runs lint checks before pushing, matching the CI workflow. To skip the hook temporarily, use `git push --no-verify`.

## License

MIT



================================================
FILE: CHANGELOG.md
================================================
# Changelog

## 0.1.6

### Features

- **Max budget control**: Added `max_budget_usd` option to set a maximum spending limit in USD for SDK sessions. When the budget is exceeded, the session will automatically terminate, helping prevent unexpected costs (#293)
- **Extended thinking configuration**: Added `max_thinking_tokens` option to control the maximum number of tokens allocated for Claude's internal reasoning process. This allows fine-tuning of the balance between response quality and token usage (#298)

### Bug Fixes

- **System prompt defaults**: Fixed issue where a default system prompt was being used when none was specified. The SDK now correctly uses an empty system prompt by default, giving users full control over agent behavior (#290)

## 0.1.5

### Features

- **Plugin support**: Added the ability to load Claude Code plugins programmatically through the SDK. Plugins can be specified using the new `plugins` field in `ClaudeAgentOptions` with a `SdkPluginConfig` type that supports loading local plugins by path. This enables SDK applications to extend functionality with custom commands and capabilities defined in plugin directories

## 0.1.4

### Features

- **Skip version check**: Added `CLAUDE_AGENT_SDK_SKIP_VERSION_CHECK` environment variable to allow users to disable the Claude Code version check. Set this environment variable to skip the minimum version validation when the SDK connects to Claude Code. (Only recommended if you already have Claude Code 2.0.0 or higher installed, otherwise some functionality may break)
- SDK MCP server tool calls can now return image content blocks

## 0.1.3

### Features

- **Strongly-typed hook inputs**: Added typed hook input structures (`PreToolUseHookInput`, `PostToolUseHookInput`, `UserPromptSubmitHookInput`, etc.) using TypedDict for better IDE autocomplete and type safety. Hook callbacks now receive fully typed input parameters

### Bug Fixes

- **Hook output field conversion**: Fixed bug where Python-safe field names (`async_`, `continue_`) in hook outputs were not being converted to CLI format (`async`, `continue`). This caused hook control fields to be silently ignored, preventing proper hook behavior. The SDK now automatically converts field names when communicating with the CLI

### Internal/Other Changes

- **CI/CD**: Re-enabled Windows testing in the end-to-end test workflow. Windows CI had been temporarily disabled but is now fully operational across all test suites

## 0.1.2

### Bug Fixes

- **Hook output fields**: Added missing hook output fields to match the TypeScript SDK, including `reason`, `continue_`, `suppressOutput`, and `stopReason`. The `decision` field now properly supports both "approve" and "block" values. Added `AsyncHookJSONOutput` type for deferred hook execution and proper typing for `hookSpecificOutput` with discriminated unions

## 0.1.1

### Features

- **Minimum Claude Code version check**: Added version validation to ensure Claude Code 2.0.0+ is installed. The SDK will display a warning if an older version is detected, helping prevent compatibility issues
- **Updated PermissionResult types**: Aligned permission result types with the latest control protocol for better type safety and compatibility

### Improvements

- **Model references**: Updated all examples and tests to use the simplified `claude-sonnet-4-5` model identifier instead of dated version strings

## 0.1.0

Introducing the Claude Agent SDK! The Claude Code SDK has been renamed to better reflect its capabilities for building AI agents across all domains, not just coding.

### Breaking Changes

#### Type Name Changes

- **ClaudeCodeOptions renamed to ClaudeAgentOptions**: The options type has been renamed to match the new SDK branding. Update all imports and type references:

  ```python
  # Before
  from claude_agent_sdk import query, ClaudeCodeOptions
  options = ClaudeCodeOptions(...)

  # After
  from claude_agent_sdk import query, ClaudeAgentOptions
  options = ClaudeAgentOptions(...)
  ```

#### System Prompt Changes

- **Merged prompt options**: The `custom_system_prompt` and `append_system_prompt` fields have been merged into a single `system_prompt` field for simpler configuration
- **No default system prompt**: The Claude Code system prompt is no longer included by default, giving you full control over agent behavior. To use the Claude Code system prompt, explicitly set:
  ```python
  system_prompt={"type": "preset", "preset": "claude_code"}
  ```

#### Settings Isolation

- **No filesystem settings by default**: Settings files (`settings.json`, `CLAUDE.md`), slash commands, and subagents are no longer loaded automatically. This ensures SDK applications have predictable behavior independent of local filesystem configurations
- **Explicit settings control**: Use the new `setting_sources` field to specify which settings locations to load: `["user", "project", "local"]`

For full migration instructions, see our [migration guide](https://docs.claude.com/en/docs/claude-code/sdk/migration-guide).

### New Features

- **Programmatic subagents**: Subagents can now be defined inline in code using the `agents` option, enabling dynamic agent creation without filesystem dependencies. [Learn more](https://docs.claude.com/en/api/agent-sdk/subagents)
- **Session forking**: Resume sessions with the new `fork_session` option to branch conversations and explore different approaches from the same starting point. [Learn more](https://docs.claude.com/en/api/agent-sdk/sessions)
- **Granular settings control**: The `setting_sources` option gives you fine-grained control over which filesystem settings to load, improving isolation for CI/CD, testing, and production deployments

### Documentation

- Comprehensive documentation now available in the [API Guide](https://docs.claude.com/en/api/agent-sdk/overview)
- New guides for [Custom Tools](https://docs.claude.com/en/api/agent-sdk/custom-tools), [Permissions](https://docs.claude.com/en/api/agent-sdk/permissions), [Session Management](https://docs.claude.com/en/api/agent-sdk/sessions), and more
- Complete [Python API reference](https://docs.claude.com/en/api/agent-sdk/python)

## 0.0.22

- Introduce custom tools, implemented as in-process MCP servers.
- Introduce hooks.
- Update internal `Transport` class to lower-level interface.
- `ClaudeSDKClient` can no longer be run in different async contexts.

## 0.0.19

- Add `ClaudeCodeOptions.add_dirs` for `--add-dir`
- Fix ClaudeCodeSDK hanging when MCP servers log to Claude Code stderr

## 0.0.18

- Add `ClaudeCodeOptions.settings` for `--settings`

## 0.0.17

- Remove dependency on asyncio for Trio compatibility

## 0.0.16

- Introduce ClaudeSDKClient for bidirectional streaming conversation
- Support Message input, not just string prompts, in query()
- Raise explicit error if the cwd does not exist

## 0.0.14

- Add safety limits to Claude Code CLI stderr reading
- Improve handling of output JSON messages split across multiple stream reads

## 0.0.13

- Update MCP (Model Context Protocol) types to align with Claude Code expectations
- Fix multi-line buffering issue
- Rename cost_usd to total_cost_usd in API responses
- Fix optional cost fields handling



================================================
FILE: CLAUDE.md
================================================
# Workflow

```bash
# Lint and style
# Check for issues and fix automatically
python -m ruff check src/ tests/ --fix
python -m ruff format src/ tests/

# Typecheck (only done for src/)
python -m mypy src/

# Run all tests
python -m pytest tests/

# Run specific test file
python -m pytest tests/test_client.py
```

# Codebase Structure

- `src/claude_agent_sdk/` - Main package
  - `client.py` - ClaudeSDKClient for interactive sessions
  - `query.py` - One-shot query function
  - `types.py` - Type definitions
  - `_internal/` - Internal implementation details
    - `transport/subprocess_cli.py` - CLI subprocess management
    - `message_parser.py` - Message parsing logic



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 Anthropic, PBC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: pyproject.toml
================================================
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "claude-agent-sdk"
version = "0.1.6"
description = "Python SDK for Claude Code"
readme = "README.md"
requires-python = ">=3.10"
license = {text = "MIT"}
authors = [
    {name = "Anthropic", email = "support@anthropic.com"},
]
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Typing :: Typed",
]
keywords = ["claude", "ai", "sdk", "anthropic"]
dependencies = [
    "anyio>=4.0.0",
    "typing_extensions>=4.0.0; python_version<'3.11'",
    "mcp>=0.1.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.20.0",
    "anyio[trio]>=4.0.0",
    "pytest-cov>=4.0.0",
    "mypy>=1.0.0",
    "ruff>=0.1.0",
]

[project.urls]
Homepage = "https://github.com/anthropics/claude-agent-sdk-python"
Documentation = "https://docs.anthropic.com/en/docs/claude-code/sdk"
Issues = "https://github.com/anthropics/claude-agent-sdk-python/issues"

[tool.hatch.build.targets.wheel]
packages = ["src/claude_agent_sdk"]

[tool.hatch.build.targets.sdist]
include = [
    "/src",
    "/tests",
    "/README.md",
    "/LICENSE",
]

[tool.pytest.ini_options]
testpaths = ["tests"]
pythonpath = ["src"]
addopts = [
    "--import-mode=importlib",
    "-p", "asyncio",
]

[tool.pytest-asyncio]
asyncio_mode = "auto"

[tool.mypy]
python_version = "3.10"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true

[tool.ruff]
target-version = "py310"
line-length = 88

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "N",  # pep8-naming
    "UP", # pyupgrade
    "B",  # flake8-bugbear
    "C4", # flake8-comprehensions
    "PTH", # flake8-use-pathlib
    "SIM", # flake8-simplify
]
ignore = [
    "E501", # line too long (handled by formatter)
]

[tool.ruff.lint.isort]
known-first-party = ["claude_agent_sdk"]


================================================
FILE: e2e-tests/README.md
================================================
# End-to-End Tests for Claude Code SDK

This directory contains end-to-end tests that run against the actual Claude API to verify real-world functionality.

## Requirements

### API Key (REQUIRED)

These tests require a valid Anthropic API key. The tests will **fail** if `ANTHROPIC_API_KEY` is not set.

Set your API key before running tests:

```bash
export ANTHROPIC_API_KEY="your-api-key-here"
```

### Dependencies

Install the development dependencies:

```bash
pip install -e ".[dev]"
```

## Running the Tests

### Run all e2e tests:

```bash
python -m pytest e2e-tests/ -v
```

### Run with e2e marker only:

```bash
python -m pytest e2e-tests/ -v -m e2e
```

### Run a specific test:

```bash
python -m pytest e2e-tests/test_mcp_calculator.py::test_basic_addition -v
```

## Cost Considerations

âš ï¸ **Important**: These tests make actual API calls to Claude, which incur costs based on your Anthropic pricing plan.

- Each test typically uses 1-3 API calls
- Tests use simple prompts to minimize token usage
- The complete test suite should cost less than $0.10 to run

## Test Coverage

### MCP Calculator Tests (`test_mcp_calculator.py`)

Tests the MCP (Model Context Protocol) integration with calculator tools:

- **test_basic_addition**: Verifies the add tool executes correctly
- **test_division**: Tests division with decimal results
- **test_square_root**: Validates square root calculations
- **test_power**: Tests exponentiation
- **test_multi_step_calculation**: Verifies multiple tools can be used in sequence
- **test_tool_permissions_enforced**: Ensures permission system works correctly

Each test validates:
1. Tools are actually called (ToolUseBlock present in response)
2. Correct tool inputs are provided
3. Expected results are returned
4. Permission system is enforced

## CI/CD Integration

These tests run automatically on:
- Pushes to `main` branch (via GitHub Actions)
- Manual workflow dispatch

The workflow uses `ANTHROPIC_API_KEY` from GitHub Secrets.

## Troubleshooting

### "ANTHROPIC_API_KEY environment variable is required" error
- Set your API key: `export ANTHROPIC_API_KEY=sk-ant-...`
- The tests will not skip - they require the key to run

### Tests timing out
- Check your API key is valid and has quota available
- Ensure network connectivity to api.anthropic.com

### Permission denied errors
- Verify the `allowed_tools` parameter includes the necessary MCP tools
- Check that tool names match the expected format (e.g., `mcp__calc__add`)

## Adding New E2E Tests

When adding new e2e tests:

1. Mark tests with `@pytest.mark.e2e` decorator
2. Use the `api_key` fixture to ensure API key is available
3. Keep prompts simple to minimize costs
4. Verify actual tool execution, not just mocked responses
5. Document any special setup requirements in this README


================================================
FILE: e2e-tests/conftest.py
================================================
"""Pytest configuration for e2e tests."""

import os

import pytest


@pytest.fixture(scope="session")
def api_key():
    """Ensure ANTHROPIC_API_KEY is set for e2e tests."""
    key = os.environ.get("ANTHROPIC_API_KEY")
    if not key:
        pytest.fail(
            "ANTHROPIC_API_KEY environment variable is required for e2e tests. "
            "Set it before running: export ANTHROPIC_API_KEY=your-key-here"
        )
    return key


@pytest.fixture(scope="session")
def event_loop_policy():
    """Use the default event loop policy for all async tests."""
    import asyncio

    return asyncio.get_event_loop_policy()


def pytest_configure(config):
    """Add e2e marker."""
    config.addinivalue_line("markers", "e2e: marks tests as e2e tests requiring API key")


================================================
FILE: e2e-tests/test_agents_and_settings.py
================================================
"""End-to-end tests for agents and setting sources with real Claude API calls."""

import asyncio
import sys
import tempfile
from pathlib import Path

import pytest

from claude_agent_sdk import (
    AgentDefinition,
    ClaudeAgentOptions,
    ClaudeSDKClient,
    SystemMessage,
)


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_agent_definition():
    """Test that custom agent definitions work."""
    options = ClaudeAgentOptions(
        agents={
            "test-agent": AgentDefinition(
                description="A test agent for verification",
                prompt="You are a test agent. Always respond with 'Test agent activated'",
                tools=["Read"],
                model="sonnet",
            )
        },
        max_turns=1,
    )

    async with ClaudeSDKClient(options=options) as client:
        await client.query("What is 2 + 2?")

        # Check that agent is available in init message
        async for message in client.receive_response():
            if isinstance(message, SystemMessage) and message.subtype == "init":
                agents = message.data.get("agents", [])
                assert isinstance(
                    agents, list
                ), f"agents should be a list of strings, got: {type(agents)}"
                assert (
                    "test-agent" in agents
                ), f"test-agent should be available, got: {agents}"
                break


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_setting_sources_default():
    """Test that default (no setting_sources) loads no settings."""
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create a temporary project with local settings
        project_dir = Path(tmpdir)
        claude_dir = project_dir / ".claude"
        claude_dir.mkdir(parents=True)

        # Create local settings with custom outputStyle
        settings_file = claude_dir / "settings.local.json"
        settings_file.write_text('{"outputStyle": "local-test-style"}')

        # Don't provide setting_sources - should default to no settings
        options = ClaudeAgentOptions(
            cwd=project_dir,
            max_turns=1,
        )

        async with ClaudeSDKClient(options=options) as client:
            await client.query("What is 2 + 2?")

            # Check that settings were NOT loaded
            async for message in client.receive_response():
                if isinstance(message, SystemMessage) and message.subtype == "init":
                    output_style = message.data.get("output_style")
                    assert (
                        output_style != "local-test-style"
                    ), f"outputStyle should NOT be from local settings (default is no settings), got: {output_style}"
                    assert (
                        output_style == "default"
                    ), f"outputStyle should be 'default', got: {output_style}"
                    break

        # On Windows, wait for file handles to be released before cleanup
        if sys.platform == "win32":
            await asyncio.sleep(0.5)


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_setting_sources_user_only():
    """Test that setting_sources=['user'] excludes project settings."""
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create a temporary project with a slash command
        project_dir = Path(tmpdir)
        commands_dir = project_dir / ".claude" / "commands"
        commands_dir.mkdir(parents=True)

        test_command = commands_dir / "testcmd.md"
        test_command.write_text(
            """---
description: Test command
---

This is a test command.
"""
        )

        # Use setting_sources=["user"] to exclude project settings
        options = ClaudeAgentOptions(
            setting_sources=["user"],
            cwd=project_dir,
            max_turns=1,
        )

        async with ClaudeSDKClient(options=options) as client:
            await client.query("What is 2 + 2?")

            # Check that project command is NOT available
            async for message in client.receive_response():
                if isinstance(message, SystemMessage) and message.subtype == "init":
                    commands = message.data.get("slash_commands", [])
                    assert (
                        "testcmd" not in commands
                    ), f"testcmd should NOT be available with user-only sources, got: {commands}"
                    break

        # On Windows, wait for file handles to be released before cleanup
        if sys.platform == "win32":
            await asyncio.sleep(0.5)


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_setting_sources_project_included():
    """Test that setting_sources=['user', 'project'] includes project settings."""
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create a temporary project with local settings
        project_dir = Path(tmpdir)
        claude_dir = project_dir / ".claude"
        claude_dir.mkdir(parents=True)

        # Create local settings with custom outputStyle
        settings_file = claude_dir / "settings.local.json"
        settings_file.write_text('{"outputStyle": "local-test-style"}')

        # Use setting_sources=["user", "project", "local"] to include local settings
        options = ClaudeAgentOptions(
            setting_sources=["user", "project", "local"],
            cwd=project_dir,
            max_turns=1,
        )

        async with ClaudeSDKClient(options=options) as client:
            await client.query("What is 2 + 2?")

            # Check that settings WERE loaded
            async for message in client.receive_response():
                if isinstance(message, SystemMessage) and message.subtype == "init":
                    output_style = message.data.get("output_style")
                    assert (
                        output_style == "local-test-style"
                    ), f"outputStyle should be from local settings, got: {output_style}"
                    break

        # On Windows, wait for file handles to be released before cleanup
        if sys.platform == "win32":
            await asyncio.sleep(0.5)


================================================
FILE: e2e-tests/test_dynamic_control.py
================================================
"""End-to-end tests for dynamic control features with real Claude API calls."""

import pytest

from claude_agent_sdk import (
    ClaudeAgentOptions,
    ClaudeSDKClient,
)


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_set_permission_mode():
    """Test that permission mode can be changed dynamically during a session."""

    options = ClaudeAgentOptions(
        permission_mode="default",
    )

    async with ClaudeSDKClient(options=options) as client:
        # Change permission mode to acceptEdits
        await client.set_permission_mode("acceptEdits")

        # Make a query that would normally require permission
        await client.query("What is 2+2? Just respond with the number.")

        async for message in client.receive_response():
            print(f"Got message: {message}")
            pass  # Just consume messages

        # Change back to default
        await client.set_permission_mode("default")

        # Make another query
        await client.query("What is 3+3? Just respond with the number.")

        async for message in client.receive_response():
            print(f"Got message: {message}")
            pass  # Just consume messages


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_set_model():
    """Test that model can be changed dynamically during a session."""

    options = ClaudeAgentOptions()

    async with ClaudeSDKClient(options=options) as client:
        # Start with default model
        await client.query("What is 1+1? Just the number.")

        async for message in client.receive_response():
            print(f"Default model response: {message}")
            pass

        # Switch to Haiku model
        await client.set_model("claude-3-5-haiku-20241022")

        await client.query("What is 2+2? Just the number.")

        async for message in client.receive_response():
            print(f"Haiku model response: {message}")
            pass

        # Switch back to default (None means default)
        await client.set_model(None)

        await client.query("What is 3+3? Just the number.")

        async for message in client.receive_response():
            print(f"Back to default model: {message}")
            pass


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_interrupt():
    """Test that interrupt can be sent during a session."""

    options = ClaudeAgentOptions()

    async with ClaudeSDKClient(options=options) as client:
        # Start a query
        await client.query("Count from 1 to 100 slowly.")

        # Send interrupt (may or may not stop the response depending on timing)
        try:
            await client.interrupt()
            print("Interrupt sent successfully")
        except Exception as e:
            print(f"Interrupt resulted in: {e}")

        # Consume any remaining messages
        async for message in client.receive_response():
            print(f"Got message after interrupt: {message}")
            pass



================================================
FILE: e2e-tests/test_hooks.py
================================================
"""End-to-end tests for hook callbacks with real Claude API calls."""

import pytest

from claude_agent_sdk import (
    ClaudeAgentOptions,
    ClaudeSDKClient,
    HookContext,
    HookInput,
    HookJSONOutput,
    HookMatcher,
)


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_hook_with_permission_decision_and_reason():
    """Test that hooks with permissionDecision and reason fields work end-to-end."""
    hook_invocations = []

    async def test_hook(
        input_data: HookInput, tool_use_id: str | None, context: HookContext
    ) -> HookJSONOutput:
        """Hook that uses permissionDecision and reason fields."""
        tool_name = input_data.get("tool_name", "")
        print(f"Hook called for tool: {tool_name}")
        hook_invocations.append(tool_name)

        # Block Bash commands for this test
        if tool_name == "Bash":
            return {
                "reason": "Bash commands are blocked in this test for safety",
                "systemMessage": "âš ï¸ Command blocked by hook",
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": "Security policy: Bash blocked",
                },
            }

        return {
            "reason": "Tool approved by security review",
            "hookSpecificOutput": {
                "hookEventName": "PreToolUse",
                "permissionDecision": "allow",
                "permissionDecisionReason": "Tool passed security checks",
            },
        }

    options = ClaudeAgentOptions(
        allowed_tools=["Bash", "Write"],
        hooks={
            "PreToolUse": [
                HookMatcher(matcher="Bash", hooks=[test_hook]),
            ],
        },
    )

    async with ClaudeSDKClient(options=options) as client:
        await client.query("Run this bash command: echo 'hello'")

        async for message in client.receive_response():
            print(f"Got message: {message}")

    print(f"Hook invocations: {hook_invocations}")
    # Verify hook was called
    assert "Bash" in hook_invocations, f"Hook should have been invoked for Bash tool, got: {hook_invocations}"


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_hook_with_continue_and_stop_reason():
    """Test that hooks with continue_=False and stopReason fields work end-to-end."""
    hook_invocations = []

    async def post_tool_hook(
        input_data: HookInput, tool_use_id: str | None, context: HookContext
    ) -> HookJSONOutput:
        """PostToolUse hook that stops execution with stopReason."""
        tool_name = input_data.get("tool_name", "")
        hook_invocations.append(tool_name)

        # Actually test continue_=False and stopReason fields
        return {
            "continue_": False,
            "stopReason": "Execution halted by test hook for validation",
            "reason": "Testing continue and stopReason fields",
            "systemMessage": "ðŸ›‘ Test hook stopped execution",
        }

    options = ClaudeAgentOptions(
        allowed_tools=["Bash"],
        hooks={
            "PostToolUse": [
                HookMatcher(matcher="Bash", hooks=[post_tool_hook]),
            ],
        },
    )

    async with ClaudeSDKClient(options=options) as client:
        await client.query("Run: echo 'test message'")

        async for message in client.receive_response():
            print(f"Got message: {message}")

    print(f"Hook invocations: {hook_invocations}")
    # Verify hook was called
    assert "Bash" in hook_invocations, f"PostToolUse hook should have been invoked, got: {hook_invocations}"


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_hook_with_additional_context():
    """Test that hooks with hookSpecificOutput work end-to-end."""
    hook_invocations = []

    async def context_hook(
        input_data: HookInput, tool_use_id: str | None, context: HookContext
    ) -> HookJSONOutput:
        """Hook that provides additional context."""
        hook_invocations.append("context_added")

        return {
            "systemMessage": "Additional context provided by hook",
            "reason": "Hook providing monitoring feedback",
            "suppressOutput": False,
            "hookSpecificOutput": {
                "hookEventName": "PostToolUse",
                "additionalContext": "The command executed successfully with hook monitoring",
            },
        }

    options = ClaudeAgentOptions(
        allowed_tools=["Bash"],
        hooks={
            "PostToolUse": [
                HookMatcher(matcher="Bash", hooks=[context_hook]),
            ],
        },
    )

    async with ClaudeSDKClient(options=options) as client:
        await client.query("Run: echo 'testing hooks'")

        async for message in client.receive_response():
            print(f"Got message: {message}")

    print(f"Hook invocations: {hook_invocations}")
    # Verify hook was called
    assert "context_added" in hook_invocations, "Hook with hookSpecificOutput should have been invoked"



================================================
FILE: e2e-tests/test_include_partial_messages.py
================================================
"""End-to-end tests for include_partial_messages option with real Claude API calls.

These tests verify that the SDK properly handles partial message streaming,
including StreamEvent parsing and message interleaving.
"""

import asyncio
from typing import List, Any

import pytest

from claude_agent_sdk import ClaudeSDKClient
from claude_agent_sdk.types import (
    ClaudeAgentOptions,
    StreamEvent,
    AssistantMessage,
    SystemMessage,
    ResultMessage,
    ThinkingBlock,
    TextBlock,
)


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_include_partial_messages_stream_events():
    """Test that include_partial_messages produces StreamEvent messages."""

    options = ClaudeAgentOptions(
        include_partial_messages=True,
        model="claude-sonnet-4-5",
        max_turns=2,
        env={
            "MAX_THINKING_TOKENS": "8000",
        },
    )

    collected_messages: List[Any] = []

    async with ClaudeSDKClient(options) as client:
        # Send a simple prompt that will generate streaming response with thinking
        await client.query("Think of three jokes, then tell one")

        async for message in client.receive_response():
            collected_messages.append(message)

    # Verify we got the expected message types
    message_types = [type(msg).__name__ for msg in collected_messages]

    # Should have SystemMessage(init) at the start
    assert message_types[0] == "SystemMessage"
    assert isinstance(collected_messages[0], SystemMessage)
    assert collected_messages[0].subtype == "init"

    # Should have multiple StreamEvent messages
    stream_events = [msg for msg in collected_messages if isinstance(msg, StreamEvent)]
    assert len(stream_events) > 0, "No StreamEvent messages received"

    # Check for expected StreamEvent types
    event_types = [event.event.get("type") for event in stream_events]
    assert "message_start" in event_types, "No message_start StreamEvent"
    assert "content_block_start" in event_types, "No content_block_start StreamEvent"
    assert "content_block_delta" in event_types, "No content_block_delta StreamEvent"
    assert "content_block_stop" in event_types, "No content_block_stop StreamEvent"
    assert "message_stop" in event_types, "No message_stop StreamEvent"

    # Should have AssistantMessage messages with thinking and text
    assistant_messages = [msg for msg in collected_messages if isinstance(msg, AssistantMessage)]
    assert len(assistant_messages) >= 1, "No AssistantMessage received"

    # Check for thinking block in at least one AssistantMessage
    has_thinking = any(
        any(isinstance(block, ThinkingBlock) for block in msg.content)
        for msg in assistant_messages
    )
    assert has_thinking, "No ThinkingBlock found in AssistantMessages"

    # Check for text block (the joke) in at least one AssistantMessage
    has_text = any(
        any(isinstance(block, TextBlock) for block in msg.content)
        for msg in assistant_messages
    )
    assert has_text, "No TextBlock found in AssistantMessages"

    # Should end with ResultMessage
    assert isinstance(collected_messages[-1], ResultMessage)
    assert collected_messages[-1].subtype == "success"


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_include_partial_messages_thinking_deltas():
    """Test that thinking content is streamed incrementally via deltas."""

    options = ClaudeAgentOptions(
        include_partial_messages=True,
        model="claude-sonnet-4-5",
        max_turns=2,
        env={
            "MAX_THINKING_TOKENS": "8000",
        },
    )

    thinking_deltas = []

    async with ClaudeSDKClient(options) as client:
        await client.query("Think step by step about what 2 + 2 equals")

        async for message in client.receive_response():
            if isinstance(message, StreamEvent):
                event = message.event
                if event.get("type") == "content_block_delta":
                    delta = event.get("delta", {})
                    if delta.get("type") == "thinking_delta":
                        thinking_deltas.append(delta.get("thinking", ""))

    # Should have received multiple thinking deltas
    assert len(thinking_deltas) > 0, "No thinking deltas received"

    # Combined thinking should form coherent text
    combined_thinking = "".join(thinking_deltas)
    assert len(combined_thinking) > 10, "Thinking content too short"

    # Should contain some reasoning about the calculation
    assert "2" in combined_thinking.lower(), "Thinking doesn't mention the numbers"


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_partial_messages_disabled_by_default():
    """Test that partial messages are not included when option is not set."""

    options = ClaudeAgentOptions(
        # include_partial_messages not set (defaults to False)
        model="claude-sonnet-4-5",
        max_turns=2,
    )

    collected_messages: List[Any] = []

    async with ClaudeSDKClient(options) as client:
        await client.query("Say hello")

        async for message in client.receive_response():
            collected_messages.append(message)

    # Should NOT have any StreamEvent messages
    stream_events = [msg for msg in collected_messages if isinstance(msg, StreamEvent)]
    assert len(stream_events) == 0, "StreamEvent messages present when partial messages disabled"

    # Should still have the regular messages
    assert any(isinstance(msg, SystemMessage) for msg in collected_messages)
    assert any(isinstance(msg, AssistantMessage) for msg in collected_messages)
    assert any(isinstance(msg, ResultMessage) for msg in collected_messages)


================================================
FILE: e2e-tests/test_sdk_mcp_tools.py
================================================
"""End-to-end tests for SDK MCP (inline) tools with real Claude API calls.

These tests verify that SDK-created MCP tools work correctly through the full stack,
focusing on tool execution mechanics rather than specific tool functionality.
"""

from typing import Any

import pytest

from claude_agent_sdk import (
    ClaudeAgentOptions,
    ClaudeSDKClient,
    create_sdk_mcp_server,
    tool,
)


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_sdk_mcp_tool_execution():
    """Test that SDK MCP tools can be called and executed with allowed_tools."""
    executions = []

    @tool("echo", "Echo back the input text", {"text": str})
    async def echo_tool(args: dict[str, Any]) -> dict[str, Any]:
        """Echo back whatever text is provided."""
        executions.append("echo")
        return {"content": [{"type": "text", "text": f"Echo: {args['text']}"}]}

    server = create_sdk_mcp_server(
        name="test",
        version="1.0.0",
        tools=[echo_tool],
    )

    options = ClaudeAgentOptions(
        mcp_servers={"test": server},
        allowed_tools=["mcp__test__echo"],
    )

    async with ClaudeSDKClient(options=options) as client:
        await client.query("Call the mcp__test__echo tool with any text")

        async for message in client.receive_response():
            pass  # Just consume messages

    # Check if the actual Python function was called
    assert "echo" in executions, "Echo tool function was not executed"


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_sdk_mcp_permission_enforcement():
    """Test that disallowed_tools prevents SDK MCP tool execution."""
    executions = []

    @tool("echo", "Echo back the input text", {"text": str})
    async def echo_tool(args: dict[str, Any]) -> dict[str, Any]:
        """Echo back whatever text is provided."""
        executions.append("echo")
        return {"content": [{"type": "text", "text": f"Echo: {args['text']}"}]}

    @tool("greet", "Greet a person by name", {"name": str})
    async def greet_tool(args: dict[str, Any]) -> dict[str, Any]:
        """Greet someone by name."""
        executions.append("greet")
        return {"content": [{"type": "text", "text": f"Hello, {args['name']}!"}]}

    server = create_sdk_mcp_server(
        name="test",
        version="1.0.0",
        tools=[echo_tool, greet_tool],
    )

    options = ClaudeAgentOptions(
        mcp_servers={"test": server},
        disallowed_tools=["mcp__test__echo"],  # Block echo tool
        allowed_tools=["mcp__test__greet"],  # But allow greet
    )

    async with ClaudeSDKClient(options=options) as client:
        await client.query(
            "Use the echo tool to echo 'test' and use greet tool to greet 'Alice'"
        )

        async for message in client.receive_response():
            pass  # Just consume messages

    # Check actual function executions
    assert "echo" not in executions, "Disallowed echo tool was executed"
    assert "greet" in executions, "Allowed greet tool was not executed"


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_sdk_mcp_multiple_tools():
    """Test that multiple SDK MCP tools can be called in sequence."""
    executions = []

    @tool("echo", "Echo back the input text", {"text": str})
    async def echo_tool(args: dict[str, Any]) -> dict[str, Any]:
        """Echo back whatever text is provided."""
        executions.append("echo")
        return {"content": [{"type": "text", "text": f"Echo: {args['text']}"}]}

    @tool("greet", "Greet a person by name", {"name": str})
    async def greet_tool(args: dict[str, Any]) -> dict[str, Any]:
        """Greet someone by name."""
        executions.append("greet")
        return {"content": [{"type": "text", "text": f"Hello, {args['name']}!"}]}

    server = create_sdk_mcp_server(
        name="multi",
        version="1.0.0",
        tools=[echo_tool, greet_tool],
    )

    options = ClaudeAgentOptions(
        mcp_servers={"multi": server},
        allowed_tools=["mcp__multi__echo", "mcp__multi__greet"],
    )

    async with ClaudeSDKClient(options=options) as client:
        await client.query(
            "Call mcp__multi__echo with text='test' and mcp__multi__greet with name='Bob'"
        )

        async for message in client.receive_response():
            pass  # Just consume messages

    # Both tools should have been executed
    assert "echo" in executions, "Echo tool was not executed"
    assert "greet" in executions, "Greet tool was not executed"


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_sdk_mcp_without_permissions():
    """Test SDK MCP tool behavior without explicit allowed_tools."""
    executions = []

    @tool("echo", "Echo back the input text", {"text": str})
    async def echo_tool(args: dict[str, Any]) -> dict[str, Any]:
        """Echo back whatever text is provided."""
        executions.append("echo")
        return {"content": [{"type": "text", "text": f"Echo: {args['text']}"}]}

    server = create_sdk_mcp_server(
        name="noperm",
        version="1.0.0",
        tools=[echo_tool],
    )

    # No allowed_tools specified
    options = ClaudeAgentOptions(
        mcp_servers={"noperm": server},
    )

    async with ClaudeSDKClient(options=options) as client:
        await client.query("Call the mcp__noperm__echo tool")

        async for message in client.receive_response():
            pass  # Just consume messages

    assert "echo" not in executions, "SDK MCP tool was executed"



================================================
FILE: e2e-tests/test_stderr_callback.py
================================================
"""End-to-end test for stderr callback functionality."""

import pytest

from claude_agent_sdk import ClaudeAgentOptions, query


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_stderr_callback_captures_debug_output():
    """Test that stderr callback receives debug output when enabled."""
    stderr_lines = []

    def capture_stderr(line: str):
        stderr_lines.append(line)

    # Enable debug mode to generate stderr output
    options = ClaudeAgentOptions(
        stderr=capture_stderr,
        extra_args={"debug-to-stderr": None}
    )

    # Run a simple query
    async for _ in query(prompt="What is 1+1?", options=options):
        pass  # Just consume messages

    # Verify we captured debug output
    assert len(stderr_lines) > 0, "Should capture stderr output with debug enabled"
    assert any("[DEBUG]" in line for line in stderr_lines), "Should contain DEBUG messages"


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_stderr_callback_without_debug():
    """Test that stderr callback works but receives no output without debug mode."""
    stderr_lines = []

    def capture_stderr(line: str):
        stderr_lines.append(line)

    # No debug mode enabled
    options = ClaudeAgentOptions(stderr=capture_stderr)

    # Run a simple query
    async for _ in query(prompt="What is 1+1?", options=options):
        pass  # Just consume messages

    # Should work but capture minimal/no output without debug
    assert len(stderr_lines) == 0, "Should not capture stderr output without debug mode"


================================================
FILE: e2e-tests/test_tool_permissions.py
================================================
"""End-to-end tests for tool permission callbacks with real Claude API calls."""

import pytest

from claude_agent_sdk import (
    ClaudeAgentOptions,
    ClaudeSDKClient,
    PermissionResultAllow,
    PermissionResultDeny,
    ToolPermissionContext,
)


@pytest.mark.e2e
@pytest.mark.asyncio
async def test_permission_callback_gets_called():
    """Test that can_use_tool callback gets invoked."""
    callback_invocations = []
    
    async def permission_callback(
        tool_name: str,
        input_data: dict,
        context: ToolPermissionContext
    ) -> PermissionResultAllow | PermissionResultDeny:
        """Track callback invocation."""
        print(f"Permission callback called for: {tool_name}, input: {input_data}")
        callback_invocations.append(tool_name)
        return PermissionResultAllow()
    
    options = ClaudeAgentOptions(
        can_use_tool=permission_callback,
    )
    
    async with ClaudeSDKClient(options=options) as client:
        await client.query("Write 'hello world' to /tmp/test.txt")
        
        async for message in client.receive_response():
            print(f"Got message: {message}")
            pass  # Just consume messages
    
    print(f'Callback invocations: {callback_invocations}')
    # Verify callback was invoked
    assert "Write" in callback_invocations, f"can_use_tool callback should have been invoked for Write tool, got: {callback_invocations}"


================================================
FILE: examples/agents.py
================================================
#!/usr/bin/env python3
"""Example of using custom agents with Claude Code SDK.

This example demonstrates how to define and use custom agents with specific
tools, prompts, and models.

Usage:
./examples/agents.py - Run the example
"""

import anyio

from claude_agent_sdk import (
    AgentDefinition,
    AssistantMessage,
    ClaudeAgentOptions,
    ResultMessage,
    TextBlock,
    query,
)


async def code_reviewer_example():
    """Example using a custom code reviewer agent."""
    print("=== Code Reviewer Agent Example ===")

    options = ClaudeAgentOptions(
        agents={
            "code-reviewer": AgentDefinition(
                description="Reviews code for best practices and potential issues",
                prompt="You are a code reviewer. Analyze code for bugs, performance issues, "
                "security vulnerabilities, and adherence to best practices. "
                "Provide constructive feedback.",
                tools=["Read", "Grep"],
                model="sonnet",
            ),
        },
    )

    async for message in query(
        prompt="Use the code-reviewer agent to review the code in src/claude_agent_sdk/types.py",
        options=options,
    ):
        if isinstance(message, AssistantMessage):
            for block in message.content:
                if isinstance(block, TextBlock):
                    print(f"Claude: {block.text}")
        elif isinstance(message, ResultMessage) and message.total_cost_usd and message.total_cost_usd > 0:
            print(f"\nCost: ${message.total_cost_usd:.4f}")
    print()


async def documentation_writer_example():
    """Example using a documentation writer agent."""
    print("=== Documentation Writer Agent Example ===")

    options = ClaudeAgentOptions(
        agents={
            "doc-writer": AgentDefinition(
                description="Writes comprehensive documentation",
                prompt="You are a technical documentation expert. Write clear, comprehensive "
                "documentation with examples. Focus on clarity and completeness.",
                tools=["Read", "Write", "Edit"],
                model="sonnet",
            ),
        },
    )

    async for message in query(
        prompt="Use the doc-writer agent to explain what AgentDefinition is used for",
        options=options,
    ):
        if isinstance(message, AssistantMessage):
            for block in message.content:
                if isinstance(block, TextBlock):
                    print(f"Claude: {block.text}")
        elif isinstance(message, ResultMessage) and message.total_cost_usd and message.total_cost_usd > 0:
            print(f"\nCost: ${message.total_cost_usd:.4f}")
    print()


async def multiple_agents_example():
    """Example with multiple custom agents."""
    print("=== Multiple Agents Example ===")

    options = ClaudeAgentOptions(
        agents={
            "analyzer": AgentDefinition(
                description="Analyzes code structure and patterns",
                prompt="You are a code analyzer. Examine code structure, patterns, and architecture.",
                tools=["Read", "Grep", "Glob"],
            ),
            "tester": AgentDefinition(
                description="Creates and runs tests",
                prompt="You are a testing expert. Write comprehensive tests and ensure code quality.",
                tools=["Read", "Write", "Bash"],
                model="sonnet",
            ),
        },
        setting_sources=["user", "project"],
    )

    async for message in query(
        prompt="Use the analyzer agent to find all Python files in the examples/ directory",
        options=options,
    ):
        if isinstance(message, AssistantMessage):
            for block in message.content:
                if isinstance(block, TextBlock):
                    print(f"Claude: {block.text}")
        elif isinstance(message, ResultMessage) and message.total_cost_usd and message.total_cost_usd > 0:
            print(f"\nCost: ${message.total_cost_usd:.4f}")
    print()


async def main():
    """Run all agent examples."""
    await code_reviewer_example()
    await documentation_writer_example()
    await multiple_agents_example()


if __name__ == "__main__":
    anyio.run(main)



================================================
FILE: examples/hooks.py
================================================
#!/usr/bin/env python
"""Example of using hooks with Claude Code SDK via ClaudeAgentOptions.

This file demonstrates various hook patterns using the hooks parameter
in ClaudeAgentOptions instead of decorator-based hooks.

Usage:
./examples/hooks.py - List the examples
./examples/hooks.py all - Run all examples
./examples/hooks.py PreToolUse - Run a specific example
"""

import asyncio
import logging
import sys
from typing import Any

from claude_agent_sdk import ClaudeAgentOptions, ClaudeSDKClient
from claude_agent_sdk.types import (
    AssistantMessage,
    HookContext,
    HookInput,
    HookJSONOutput,
    HookMatcher,
    Message,
    ResultMessage,
    TextBlock,
)

# Set up logging to see what's happening
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(message)s")
logger = logging.getLogger(__name__)


def display_message(msg: Message) -> None:
    """Standardized message display function."""
    if isinstance(msg, AssistantMessage):
        for block in msg.content:
            if isinstance(block, TextBlock):
                print(f"Claude: {block.text}")
    elif isinstance(msg, ResultMessage):
        print("Result ended")


##### Hook callback functions
async def check_bash_command(
    input_data: HookInput, tool_use_id: str | None, context: HookContext
) -> HookJSONOutput:
    """Prevent certain bash commands from being executed."""
    tool_name = input_data["tool_name"]
    tool_input = input_data["tool_input"]

    if tool_name != "Bash":
        return {}

    command = tool_input.get("command", "")
    block_patterns = ["foo.sh"]

    for pattern in block_patterns:
        if pattern in command:
            logger.warning(f"Blocked command: {command}")
            return {
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": f"Command contains invalid pattern: {pattern}",
                }
            }

    return {}


async def add_custom_instructions(
    input_data: HookInput, tool_use_id: str | None, context: HookContext
) -> HookJSONOutput:
    """Add custom instructions when a session starts."""
    return {
        "hookSpecificOutput": {
            "hookEventName": "SessionStart",
            "additionalContext": "My favorite color is hot pink",
        }
    }


async def review_tool_output(
    input_data: HookInput, tool_use_id: str | None, context: HookContext
) -> HookJSONOutput:
    """Review tool output and provide additional context or warnings."""
    tool_response = input_data.get("tool_response", "")

    # If the tool produced an error, add helpful context
    if "error" in str(tool_response).lower():
        return {
            "systemMessage": "âš ï¸ The command produced an error",
            "reason": "Tool execution failed - consider checking the command syntax",
            "hookSpecificOutput": {
                "hookEventName": "PostToolUse",
                "additionalContext": "The command encountered an error. You may want to try a different approach.",
            }
        }

    return {}


async def strict_approval_hook(
    input_data: HookInput, tool_use_id: str | None, context: HookContext
) -> HookJSONOutput:
    """Demonstrates using permissionDecision to control tool execution."""
    tool_name = input_data.get("tool_name")
    tool_input = input_data.get("tool_input", {})

    # Block any Write operations to specific files
    if tool_name == "Write":
        file_path = tool_input.get("file_path", "")
        if "important" in file_path.lower():
            logger.warning(f"Blocked Write to: {file_path}")
            return {
                "reason": "Writes to files containing 'important' in the name are not allowed for safety",
                "systemMessage": "ðŸš« Write operation blocked by security policy",
                "hookSpecificOutput": {
                    "hookEventName": "PreToolUse",
                    "permissionDecision": "deny",
                    "permissionDecisionReason": "Security policy blocks writes to important files",
                },
            }

    # Allow everything else explicitly
    return {
        "reason": "Tool use approved after security review",
        "hookSpecificOutput": {
            "hookEventName": "PreToolUse",
            "permissionDecision": "allow",
            "permissionDecisionReason": "Tool passed security checks",
        },
    }


async def stop_on_error_hook(
    input_data: HookInput, tool_use_id: str | None, context: HookContext
) -> HookJSONOutput:
    """Demonstrates using continue=False to stop execution on certain conditions."""
    tool_response = input_data.get("tool_response", "")

    # Stop execution if we see a critical error
    if "critical" in str(tool_response).lower():
        logger.error("Critical error detected - stopping execution")
        return {
            "continue_": False,
            "stopReason": "Critical error detected in tool output - execution halted for safety",
            "systemMessage": "ðŸ›‘ Execution stopped due to critical error",
        }

    return {"continue_": True}


async def example_pretooluse() -> None:
    """Basic example demonstrating hook protection."""
    print("=== PreToolUse Example ===")
    print("This example demonstrates how PreToolUse can block some bash commands but not others.\n")

    # Configure hooks using ClaudeAgentOptions
    options = ClaudeAgentOptions(
        allowed_tools=["Bash"],
        hooks={
            "PreToolUse": [
                HookMatcher(matcher="Bash", hooks=[check_bash_command]),
            ],
        }
    )

    async with ClaudeSDKClient(options=options) as client:
        # Test 1: Command with forbidden pattern (will be blocked)
        print("Test 1: Trying a command that our PreToolUse hook should block...")
        print("User: Run the bash command: ./foo.sh --help")
        await client.query("Run the bash command: ./foo.sh --help")

        async for msg in client.receive_response():
            display_message(msg)

        print("\n" + "=" * 50 + "\n")

        # Test 2: Safe command that should work
        print("Test 2: Trying a command that our PreToolUse hook should allow...")
        print("User: Run the bash command: echo 'Hello from hooks example!'")
        await client.query("Run the bash command: echo 'Hello from hooks example!'")

        async for msg in client.receive_response():
            display_message(msg)

        print("\n" + "=" * 50 + "\n")

    print("\n")


async def example_userpromptsubmit() -> None:
    """Demonstrate context retention across conversation."""
    print("=== UserPromptSubmit Example ===")
    print("This example shows how a UserPromptSubmit hook can add context.\n")

    options = ClaudeAgentOptions(
        hooks={
            "UserPromptSubmit": [
                HookMatcher(matcher=None, hooks=[add_custom_instructions]),
            ],
        }
    )

    async with ClaudeSDKClient(options=options) as client:
        print("User: What's my favorite color?")
        await client.query("What's my favorite color?")

        async for msg in client.receive_response():
            display_message(msg)

    print("\n")


async def example_posttooluse() -> None:
    """Demonstrate PostToolUse hook with reason and systemMessage fields."""
    print("=== PostToolUse Example ===")
    print("This example shows how PostToolUse can provide feedback with reason and systemMessage.\n")

    options = ClaudeAgentOptions(
        allowed_tools=["Bash"],
        hooks={
            "PostToolUse": [
                HookMatcher(matcher="Bash", hooks=[review_tool_output]),
            ],
        }
    )

    async with ClaudeSDKClient(options=options) as client:
        print("User: Run a command that will produce an error: ls /nonexistent_directory")
        await client.query("Run this command: ls /nonexistent_directory")

        async for msg in client.receive_response():
            display_message(msg)

    print("\n")


async def example_decision_fields() -> None:
    """Demonstrate permissionDecision, reason, and systemMessage fields."""
    print("=== Permission Decision Example ===")
    print("This example shows how to use permissionDecision='allow'/'deny' with reason and systemMessage.\n")

    options = ClaudeAgentOptions(
        allowed_tools=["Write", "Bash"],
        model="claude-sonnet-4-5-20250929",
        hooks={
            "PreToolUse": [
                HookMatcher(matcher="Write", hooks=[strict_approval_hook]),
            ],
        }
    )

    async with ClaudeSDKClient(options=options) as client:
        # Test 1: Try to write to a file with "important" in the name (should be blocked)
        print("Test 1: Trying to write to important_config.txt (should be blocked)...")
        print("User: Write 'test' to important_config.txt")
        await client.query("Write the text 'test data' to a file called important_config.txt")

        async for msg in client.receive_response():
            display_message(msg)

        print("\n" + "=" * 50 + "\n")

        # Test 2: Write to a regular file (should be approved)
        print("Test 2: Trying to write to regular_file.txt (should be approved)...")
        print("User: Write 'test' to regular_file.txt")
        await client.query("Write the text 'test data' to a file called regular_file.txt")

        async for msg in client.receive_response():
            display_message(msg)

    print("\n")


async def example_continue_control() -> None:
    """Demonstrate continue and stopReason fields for execution control."""
    print("=== Continue/Stop Control Example ===")
    print("This example shows how to use continue_=False with stopReason to halt execution.\n")

    options = ClaudeAgentOptions(
        allowed_tools=["Bash"],
        hooks={
            "PostToolUse": [
                HookMatcher(matcher="Bash", hooks=[stop_on_error_hook]),
            ],
        }
    )

    async with ClaudeSDKClient(options=options) as client:
        print("User: Run a command that outputs 'CRITICAL ERROR'")
        await client.query("Run this bash command: echo 'CRITICAL ERROR: system failure'")

        async for msg in client.receive_response():
            display_message(msg)

    print("\n")


async def main() -> None:
    """Run all examples or a specific example based on command line argument."""
    examples = {
        "PreToolUse": example_pretooluse,
        "UserPromptSubmit": example_userpromptsubmit,
        "PostToolUse": example_posttooluse,
        "DecisionFields": example_decision_fields,
        "ContinueControl": example_continue_control,
    }

    if len(sys.argv) < 2:
        # List available examples
        print("Usage: python hooks.py <example_name>")
        print("\nAvailable examples:")
        print("  all - Run all examples")
        for name in examples:
            print(f"  {name}")
        print("\nExample descriptions:")
        print("  PreToolUse       - Block commands using PreToolUse hook")
        print("  UserPromptSubmit - Add context at prompt submission")
        print("  PostToolUse      - Review tool output with reason and systemMessage")
        print("  DecisionFields   - Use permissionDecision='allow'/'deny' with reason")
        print("  ContinueControl  - Control execution with continue_ and stopReason")
        sys.exit(0)

    example_name = sys.argv[1]

    if example_name == "all":
        # Run all examples
        for example in examples.values():
            await example()
            print("-" * 50 + "\n")
    elif example_name in examples:
        # Run specific example
        await examples[example_name]()
    else:
        print(f"Error: Unknown example '{example_name}'")
        print("\nAvailable examples:")
        print("  all - Run all examples")
        for name in examples:
            print(f"  {name}")
        sys.exit(1)


if __name__ == "__main__":
    print("Starting Claude SDK Hooks Examples...")
    print("=" * 50 + "\n")
    asyncio.run(main())

